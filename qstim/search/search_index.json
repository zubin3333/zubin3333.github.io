{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"QStim Device Manual This is the online manual for the QStim stimulator, it covers both the hardware and the software usage of device.","title":"QStim Device Manual"},{"location":"#qstim-device-manual","text":"This is the online manual for the QStim stimulator, it covers both the hardware and the software usage of device.","title":"QStim Device Manual"},{"location":"hardware/","text":"Hardware Overview Device Diagram This section of the manual covers all the connection points on the stimulator, and how to establish a connection with the device over USB.","title":"Hardware Overview"},{"location":"hardware/#hardware-overview","text":"","title":"Hardware Overview"},{"location":"hardware/#device-diagram","text":"This section of the manual covers all the connection points on the stimulator, and how to establish a connection with the device over USB.","title":"Device Diagram"},{"location":"quickstart/","text":"Quick Start Guide The purpose of this guide is to show the user how to get the stimulator connected to a PC and ready to stimulate as quickly as possible using free software. This guide will cover both Windows and macOS. Windows Download and install Tera Term . Plug the stimulator into a USB port on the PC using the provided cable. Open Tera Term, the following prompt should appear. Click the Serial text so that the radio button next to it is filled. Then press OK at the bottom of the window. Click the setup drop down menu and then click the Serial Port... entry. The following window will appear. Click on the Port drop down menu, if you see only one COM entry then skip this step and go to step 6. If you see multiple entries eg. COM4 and COM5, it means that there are multiple COM ports available on the PC and the correct one needs to be found. Select each of the COM ports in the menu and look at the Device Manufacturer field at the bottom (in red rectangle). Find the port that shows FTDI as the manufacturer. If more than one device comes up with FTDI as the manufacturer, disconnect as many other USB devices as possible to eliminate them as an option. Set the Speed, Data, Parity, Stop Bits, Flow Control and Transmit Delay to the settings seen in the image below. And press the New Setting button (if you changed the port setting the text on the button may be different but it is still the correct button to press). Hit the ENTER key on the keyboard and the text stim> should appear, this is the shell prompt provided by the device. Commands like help can be entered followed by hitting the ENTER key to control the device. macOS Plug the stimulator into a USB port on the Mac using the provided cable. Open Terminal from the Utilities folder in the Applications folder on the Mac using Finder. Type ls /dev/cu.* into the window and hit the return (or enter) key on the keyboard. You should get a printout of the available serial devices on the Mac. Look for an entry with the word \"usbserial\" in it. Type in screen /dev/cu.PLACE-HOLDER 115200 replacing PLACE-HOLDER with the correct text found in step 3. (You can simply copy paste in the text). Don't forget the number 115200, this indicates the correct communication speed of the device. Hit the return key. Hit the return key on the keyboard and the text stim> should appear, this is the shell prompt provided by the device. Commands like help can be entered followed by hitting the return key to control the device. Basic Stimulation Now that the device can be controlled, it can now be set to stimulate some connected electrodes. Follow the steps below to do some basic stimulation. The device will be set to stimulate infinitely until a command to stop is sent. At the stim> prompt type window pulses -1 to set the stimulator to stimulate infinitely. Hit the ENTER key. At the stim> prompt type current p1 1000 to produce 1000uA during phase 1. Hit the ENTER key. At the stim> prompt type current p2 -1000 to produce -1000uA during phase 2. Hit the ENTER key. At the stim> prompt type time rate 500 20 500 100 to set phase 1 time to 500us, interphase to 20us, phase 2 to 500us and the stimulation rate to 100Hz. Hit the ENTER key. At the stim> prompt type flag iso on to isolate the stimulator from the electrode during the interphase. Hit the ENTER key. At the stim> prompt type flag short on to short the electrodes during the inter-stim. Hit the ENTER key. At the stim> prompt type flag power on to turn on the outputs of the stimulator. Hit the ENTER key. At the stim> prompt type run to start stimulation. Hit the ENTER key. Type stop and hit ENTER to stop stimulating. The orange LED should flash during stimulation. The interaction with the stimulator using the commands above can be seen in the screenshot below. The stimulator provides feedback on the entry of every command to indicate to the user what parameter has changed, or to let the user know when a mistake has been made on entry. The stimulator should then be stimulating using those parameters from all 4 channel outputs. This does not cover the full functionality of the device. For more details on how to control the stimulator proceed to the shell manual.","title":"Quick Start Guide"},{"location":"quickstart/#quick-start-guide","text":"The purpose of this guide is to show the user how to get the stimulator connected to a PC and ready to stimulate as quickly as possible using free software. This guide will cover both Windows and macOS.","title":"Quick Start Guide"},{"location":"quickstart/#windows","text":"Download and install Tera Term . Plug the stimulator into a USB port on the PC using the provided cable. Open Tera Term, the following prompt should appear. Click the Serial text so that the radio button next to it is filled. Then press OK at the bottom of the window. Click the setup drop down menu and then click the Serial Port... entry. The following window will appear. Click on the Port drop down menu, if you see only one COM entry then skip this step and go to step 6. If you see multiple entries eg. COM4 and COM5, it means that there are multiple COM ports available on the PC and the correct one needs to be found. Select each of the COM ports in the menu and look at the Device Manufacturer field at the bottom (in red rectangle). Find the port that shows FTDI as the manufacturer. If more than one device comes up with FTDI as the manufacturer, disconnect as many other USB devices as possible to eliminate them as an option. Set the Speed, Data, Parity, Stop Bits, Flow Control and Transmit Delay to the settings seen in the image below. And press the New Setting button (if you changed the port setting the text on the button may be different but it is still the correct button to press). Hit the ENTER key on the keyboard and the text stim> should appear, this is the shell prompt provided by the device. Commands like help can be entered followed by hitting the ENTER key to control the device.","title":"Windows"},{"location":"quickstart/#macos","text":"Plug the stimulator into a USB port on the Mac using the provided cable. Open Terminal from the Utilities folder in the Applications folder on the Mac using Finder. Type ls /dev/cu.* into the window and hit the return (or enter) key on the keyboard. You should get a printout of the available serial devices on the Mac. Look for an entry with the word \"usbserial\" in it. Type in screen /dev/cu.PLACE-HOLDER 115200 replacing PLACE-HOLDER with the correct text found in step 3. (You can simply copy paste in the text). Don't forget the number 115200, this indicates the correct communication speed of the device. Hit the return key. Hit the return key on the keyboard and the text stim> should appear, this is the shell prompt provided by the device. Commands like help can be entered followed by hitting the return key to control the device.","title":"macOS"},{"location":"quickstart/#basic-stimulation","text":"Now that the device can be controlled, it can now be set to stimulate some connected electrodes. Follow the steps below to do some basic stimulation. The device will be set to stimulate infinitely until a command to stop is sent. At the stim> prompt type window pulses -1 to set the stimulator to stimulate infinitely. Hit the ENTER key. At the stim> prompt type current p1 1000 to produce 1000uA during phase 1. Hit the ENTER key. At the stim> prompt type current p2 -1000 to produce -1000uA during phase 2. Hit the ENTER key. At the stim> prompt type time rate 500 20 500 100 to set phase 1 time to 500us, interphase to 20us, phase 2 to 500us and the stimulation rate to 100Hz. Hit the ENTER key. At the stim> prompt type flag iso on to isolate the stimulator from the electrode during the interphase. Hit the ENTER key. At the stim> prompt type flag short on to short the electrodes during the inter-stim. Hit the ENTER key. At the stim> prompt type flag power on to turn on the outputs of the stimulator. Hit the ENTER key. At the stim> prompt type run to start stimulation. Hit the ENTER key. Type stop and hit ENTER to stop stimulating. The orange LED should flash during stimulation. The interaction with the stimulator using the commands above can be seen in the screenshot below. The stimulator provides feedback on the entry of every command to indicate to the user what parameter has changed, or to let the user know when a mistake has been made on entry. The stimulator should then be stimulating using those parameters from all 4 channel outputs. This does not cover the full functionality of the device. For more details on how to control the stimulator proceed to the shell manual.","title":"Basic Stimulation"},{"location":"shell/","text":"Software Manual The device provides a shell interface over a virtual serial port over USB that can be accessed by any terminal emulator on all major operating systems. Refer to the user manual and the getting started guide to learn how to connect to the device. This manual covers how to use the shell interface of the stimulator once a connection has been established. Interacting with the interface Any user that has used a command prompt interface on some platform in the past will be able to quickly understand the interface provided by this device. The device prompts the user to type in a command with stim> . Once a command has been type in, the enter key can be pressed, at which point the command is processed by the stimulator. The stimulator will respond with a confirmation of the change made. It will then prompt the user for the next command with stim> , and again the user can enter another command. See below for an example interaction to set a current output. stim> current p1 1000 Current on Phase 1 of all channels set to 1000 stim> Like most command line interfaces, the user can use Backspace to delete characters in a command to re-enter characters. Additionally the Up and Down keyboard keys can be used to navigate the history of commands run on the device. After the user has type the first few letters of a command name the Tab key can be presses to autocomplete the rest of the command in the same manner as other command line interfaces on other platforms. If no command has been entered and the Enter key is pressed the stimulator will simply re-prompt the user for another command without any adverse affect. Help and Usage Information Help is the only command one needs to remember, from this one command all other usage information can be derived. Simply type help followed by the Enter key. This provides a list of commands that can be used on the device. Additionally, each command is has some usage information attached to it, that is displayed when the user makes a mistake using it. Intentionally making a mistake is a quick way to quickly refresh ones memory on how to use a command as it will bring up the usage message. For example the command current can be entered leaving out any parameters to trigger the message to appear. stim> help Commands: help info echo systime mem threads test run stop status boardinfo tests window current time flag adcstart adcstop adcread eeprom calibrate setdac seeadc stim> current Usage: current [ch1|ch2|ch3|ch4] {p1|p2} <microampere> How to read the usage information The usage instructions are guided by the notation outlined in the Microsoft Command-Line Syntax Key . A summary of the notation: <some text> must be replaced by a number [some text] indicates an optional parameter {some text} set of required items. You must choose one. | separates items that can be repeated and used multiple times. For example the usage instruction for current Usage: current [ch1|ch2|ch3|ch4] {p1|p2} <microampere> shows that the user must type in current . Next if they can choose either to type in a channel like ch1 or skip it. Next they must provide which phase they want to set either by typing p1 or p2 . Finally they must give a number to indicate the amount of current that should flow. Commands Current The current command is used to set the current that flows in the phases during stimulation. Each phase on each channel can be set independently. stim> current Usage: current [ch1|ch2|ch3|ch4] {p1|p2} <microampere> If the user would like -1000 microampere to flow during phase 1 on channel 1 of the stimulator, they would enter the following command: stim> current ch1 p1 -1000 If the user would like to change the current across all four channels to 1000 microampere in phase 2, they can simply omit the optional channel parameter, making the change global. stim> current p2 1000 Time Unlike current , time can not be changed independently for each channel. All the channels run on the same time base. The stimulation timing is defined by 4 parameters p1 (phase 1), ip (inter-phase gap), p2 (phase 2) and is (inter-stimulation delay). stim> time Usage: time {p1|ip|p2|is} <microseconds> Usage: time rate <p1 time (us)> <ip time (us)> <p2 time (us)> <rate (Hz)> The time on any of the 4 time parameters can be set to a value in microseconds. The user type in time followed by the part of the waveform they want to set a time for, followed by an integer indicating the number of microseconds. For example: stim> time p1 500 Alternatively the user can also specify the timing parameters in terms of a rate. In this case the user sets the phase 1, inter-phase gap and phase 2 times and also provides a rate in Hz. The stimulator will then set the inter-stimulation delay to the correct value to achieve that rate. An example where 500 microsecond phase times, 20 microsecond inter-phase gap and a rate of 100Hz is set: stim> time rate 500 20 500 100 Window The window command is used to define the three window parameters. stim> window Usage: window {number|pulses|space} <number/microseconds> number defines the number of time the window should be repeated. pulses defines the number of biphasic waveforms in a single window. space defines the amount of time in microseconds between the last biphasic in a window and the end of the window. number and pulses can be set to infinite by providing the value -1. It is important to note that when pulses is set to infinite, the other window parameters become redundant since they will never be reached. Example usage: stim> window pulses 1200 Flag The flag command can be used to turn on or off a range of features on the device. stim> flag Usage: flag [ch1|ch2|ch3|ch4] {short|cap|dummy|iso|power} {on|off} Usage: flag trig {on|off} A range of channel specific features can be set on the device: short toggles electrode shorting during the inter-stim delay, cap toggles the existence of a series cap on the output, dummy toggles the existence of a dummy load on the output, iso toggles whether the electrode is electrically disconnected during inter-phase gap and inter-stim delay, power toggles the output of the channel. Usage example: stim> flag ch1 short on Optionally, the channel parameter can be left out to apply the change all four channels of the stimulator. stim> flag short on Triggering is a global flag that cannot be set independently for each channel as all the channels run on the same time base. Example usage: stim> flag trig on Run The run command puts the stimulator into a \"running\" state. If triggering is disabled, the stimulator will begin to stimulate immediately. Otherwise it will wait for a trigger signal on the trigger input to start the stimulation waveform. stim> run The run command does not work twice in a row, the stop command must be used between the uses of run to reset the stimulator. Stop The stop command takes the stimulator out of a \"running\" state, resetting its progress, waiting for another run command. It will immediately stop producing current at the channels. This also applies if the stimulator was waiting for a trigger and had never started or had finished the waveform. stim> stop The stop command must always be used to end a stimulation, even when the stimulation has completed, this is because the stimulator hardware would still be in a \"running\" state. This allows for re-triggering of the waveform by external hardware (a common use case). Status The status command prints out the current state of the parameters entered by the user. stim> status Global: Algorithm: 0 Flags: NO_TRIGEN Window Pulse No.: 4294967295 Window Space: 0 us Window No.: 600000 Time P1: 500 us Time P2: 500 us Time IP: 20 us Time IS: 8980 us Channel 1: Current P1: -1000 uA Current P2: 1000 uA Current DC: 0 Flags: SHORT NO_CAP NO_DUMMY ISO POWER Channel 2: Current P1: -1000 uA Current P2: 1000 uA Current DC: 0 Flags: SHORT NO_CAP NO_DUMMY ISO POWER Channel 3: Current P1: -1000 uA Current P2: 1000 uA Current DC: 0 Flags: SHORT NO_CAP NO_DUMMY ISO POWER Channel 4: Current P1: -1000 uA Current P2: 1000 uA Current DC: 0 Flags: SHORT NO_CAP NO_DUMMY ISO POWER","title":"Software Manual"},{"location":"shell/#software-manual","text":"The device provides a shell interface over a virtual serial port over USB that can be accessed by any terminal emulator on all major operating systems. Refer to the user manual and the getting started guide to learn how to connect to the device. This manual covers how to use the shell interface of the stimulator once a connection has been established.","title":"Software Manual"},{"location":"shell/#interacting-with-the-interface","text":"Any user that has used a command prompt interface on some platform in the past will be able to quickly understand the interface provided by this device. The device prompts the user to type in a command with stim> . Once a command has been type in, the enter key can be pressed, at which point the command is processed by the stimulator. The stimulator will respond with a confirmation of the change made. It will then prompt the user for the next command with stim> , and again the user can enter another command. See below for an example interaction to set a current output. stim> current p1 1000 Current on Phase 1 of all channels set to 1000 stim> Like most command line interfaces, the user can use Backspace to delete characters in a command to re-enter characters. Additionally the Up and Down keyboard keys can be used to navigate the history of commands run on the device. After the user has type the first few letters of a command name the Tab key can be presses to autocomplete the rest of the command in the same manner as other command line interfaces on other platforms. If no command has been entered and the Enter key is pressed the stimulator will simply re-prompt the user for another command without any adverse affect.","title":"Interacting with the interface"},{"location":"shell/#help-and-usage-information","text":"Help is the only command one needs to remember, from this one command all other usage information can be derived. Simply type help followed by the Enter key. This provides a list of commands that can be used on the device. Additionally, each command is has some usage information attached to it, that is displayed when the user makes a mistake using it. Intentionally making a mistake is a quick way to quickly refresh ones memory on how to use a command as it will bring up the usage message. For example the command current can be entered leaving out any parameters to trigger the message to appear. stim> help Commands: help info echo systime mem threads test run stop status boardinfo tests window current time flag adcstart adcstop adcread eeprom calibrate setdac seeadc stim> current Usage: current [ch1|ch2|ch3|ch4] {p1|p2} <microampere>","title":"Help and Usage Information"},{"location":"shell/#how-to-read-the-usage-information","text":"The usage instructions are guided by the notation outlined in the Microsoft Command-Line Syntax Key . A summary of the notation: <some text> must be replaced by a number [some text] indicates an optional parameter {some text} set of required items. You must choose one. | separates items that can be repeated and used multiple times. For example the usage instruction for current Usage: current [ch1|ch2|ch3|ch4] {p1|p2} <microampere> shows that the user must type in current . Next if they can choose either to type in a channel like ch1 or skip it. Next they must provide which phase they want to set either by typing p1 or p2 . Finally they must give a number to indicate the amount of current that should flow.","title":"How to read the usage information"},{"location":"shell/#commands","text":"","title":"Commands"},{"location":"shell/#current","text":"The current command is used to set the current that flows in the phases during stimulation. Each phase on each channel can be set independently. stim> current Usage: current [ch1|ch2|ch3|ch4] {p1|p2} <microampere> If the user would like -1000 microampere to flow during phase 1 on channel 1 of the stimulator, they would enter the following command: stim> current ch1 p1 -1000 If the user would like to change the current across all four channels to 1000 microampere in phase 2, they can simply omit the optional channel parameter, making the change global. stim> current p2 1000","title":"Current"},{"location":"shell/#time","text":"Unlike current , time can not be changed independently for each channel. All the channels run on the same time base. The stimulation timing is defined by 4 parameters p1 (phase 1), ip (inter-phase gap), p2 (phase 2) and is (inter-stimulation delay). stim> time Usage: time {p1|ip|p2|is} <microseconds> Usage: time rate <p1 time (us)> <ip time (us)> <p2 time (us)> <rate (Hz)> The time on any of the 4 time parameters can be set to a value in microseconds. The user type in time followed by the part of the waveform they want to set a time for, followed by an integer indicating the number of microseconds. For example: stim> time p1 500 Alternatively the user can also specify the timing parameters in terms of a rate. In this case the user sets the phase 1, inter-phase gap and phase 2 times and also provides a rate in Hz. The stimulator will then set the inter-stimulation delay to the correct value to achieve that rate. An example where 500 microsecond phase times, 20 microsecond inter-phase gap and a rate of 100Hz is set: stim> time rate 500 20 500 100","title":"Time"},{"location":"shell/#window","text":"The window command is used to define the three window parameters. stim> window Usage: window {number|pulses|space} <number/microseconds> number defines the number of time the window should be repeated. pulses defines the number of biphasic waveforms in a single window. space defines the amount of time in microseconds between the last biphasic in a window and the end of the window. number and pulses can be set to infinite by providing the value -1. It is important to note that when pulses is set to infinite, the other window parameters become redundant since they will never be reached. Example usage: stim> window pulses 1200","title":"Window"},{"location":"shell/#flag","text":"The flag command can be used to turn on or off a range of features on the device. stim> flag Usage: flag [ch1|ch2|ch3|ch4] {short|cap|dummy|iso|power} {on|off} Usage: flag trig {on|off} A range of channel specific features can be set on the device: short toggles electrode shorting during the inter-stim delay, cap toggles the existence of a series cap on the output, dummy toggles the existence of a dummy load on the output, iso toggles whether the electrode is electrically disconnected during inter-phase gap and inter-stim delay, power toggles the output of the channel. Usage example: stim> flag ch1 short on Optionally, the channel parameter can be left out to apply the change all four channels of the stimulator. stim> flag short on Triggering is a global flag that cannot be set independently for each channel as all the channels run on the same time base. Example usage: stim> flag trig on","title":"Flag"},{"location":"shell/#run","text":"The run command puts the stimulator into a \"running\" state. If triggering is disabled, the stimulator will begin to stimulate immediately. Otherwise it will wait for a trigger signal on the trigger input to start the stimulation waveform. stim> run The run command does not work twice in a row, the stop command must be used between the uses of run to reset the stimulator.","title":"Run"},{"location":"shell/#stop","text":"The stop command takes the stimulator out of a \"running\" state, resetting its progress, waiting for another run command. It will immediately stop producing current at the channels. This also applies if the stimulator was waiting for a trigger and had never started or had finished the waveform. stim> stop The stop command must always be used to end a stimulation, even when the stimulation has completed, this is because the stimulator hardware would still be in a \"running\" state. This allows for re-triggering of the waveform by external hardware (a common use case).","title":"Stop"},{"location":"shell/#status","text":"The status command prints out the current state of the parameters entered by the user. stim> status Global: Algorithm: 0 Flags: NO_TRIGEN Window Pulse No.: 4294967295 Window Space: 0 us Window No.: 600000 Time P1: 500 us Time P2: 500 us Time IP: 20 us Time IS: 8980 us Channel 1: Current P1: -1000 uA Current P2: 1000 uA Current DC: 0 Flags: SHORT NO_CAP NO_DUMMY ISO POWER Channel 2: Current P1: -1000 uA Current P2: 1000 uA Current DC: 0 Flags: SHORT NO_CAP NO_DUMMY ISO POWER Channel 3: Current P1: -1000 uA Current P2: 1000 uA Current DC: 0 Flags: SHORT NO_CAP NO_DUMMY ISO POWER Channel 4: Current P1: -1000 uA Current P2: 1000 uA Current DC: 0 Flags: SHORT NO_CAP NO_DUMMY ISO POWER","title":"Status"},{"location":"technical/","text":"Technical Information This document covers technical information regarding the device, that may be of interest to the advanced user or researcher that needs to understand how the device works at the low levels. The information in here is not required to be read in order to use the device in most circumstances. The quick start guide and user manuals should be the first place to look for help. Calibration The Qstim uses both DACs and ADCs to move between the analog and digital domains on the device. The DAC is responsible for converting a current value that is input by the user into a voltage value that is fed to an onboard voltage controlled current source (VCCS) that produces the current output to one of the four outputs on the device. The ADCs are responsible for turning the voltages produced by circuitry that measures channel voltage and current into integer values that can be handled and processed by the processor. In an ideal world where all the electrical components used perfectly match their specified values and the data converter is absolutely linear, the relationship between the data converters digital and analog value is simple and constant across all the devices that have been manufactured. In the real world, this relationship is more complex and varies from device to device. In order to compensate for these differences, the devices have had to incorporate a calibration system that allows each of them to be calibrated according its unique hardware characteristics. Calibration System Overview The calibration data is device specific, it depends on the culmination of errors in the electrical components present on the board. For this reason, this data is not built into the firmware, but is stored on an I2C EEPROM present on the device. This makes it easy for the user to re-calibrate the device themselves through the Shell interface Shell Manual. The use of an external EEPROM allows the firmware to stay consistent across all the devices in circulation and makes EEPROM failure a simpler and more cost effective issue to deal with. The EEPROM is completely managed by the processor on board the device, there is no need to use an external programmer to load calibration data, it is both written and read through the devices processor. Calibration Paradigm Calibration revolves around mapping a data converter value to a physical property that is being measured or produced either directly or indirectly by the data converter. If the relationship between the two is linear, then all that is required is a some offset and scale value (y = mx+b) to map between the two. If the relationship isn't linear then it can get more complicated. While a mathematical expression relating the two nicely might exist. The development/evaluation of that expression in a reasonable time, might not be possible on a microprocessor with limited performance. A popular calibration paradigm on microprocessors involves lookup tables (LUTs). A LUT stores the physical property value that should be measured/ produced by the data converter for every single input/output level of the data converter. The performance overhead is tiny for the processor to translate between the two values, but comes at the cost of memory consumption. A 12-bit data converter (the resolution of all the data converters used in the device), requires a LUT with 4096 entries to map each level. Due to the large number of data converters used in this device, LUTs could not be implemented. The paradigm chosen was a combination of both the LUT and linear offset and scale. A low density lookup table that maps regularly spaced points in the data converter/physical property relationship is used and linear interpolation is used between the points. Naturally the higher the point density, the more accurate the conversion. This density is controlled by the firmware and has been set to ensure that enough memory is present for other processes. A graphical representation of this paradigm can be seen below. DAC Value DAC Va... Output Property Output... 0 0 4095 4095 Real Relationship Real R... Interpolation between LUT points Interp... Regular Intervals Regula... Viewer does not support full SVG 1.1 The red line represents the relationship between the data converter values and physical properties. The points of contact between the red and blue line represent the points stored in the LUT. Values between these LUT points are linearly interpolated from them. Naturally the least amount of error is present where the blue and red lines are coincident. However as the data converters and the circuits that follow in this device are mostly linear, very little error is present in values between two interpolation points. It is intentional that the points in the LUT have a regular interval on the axis that is being translated from. The reason for this is that there is less of a processing overhead in finding which interval a given value falls in than if the intervals were irregularly sized. This is important as the current to DAC value needs to be done fast to allow for current updates during a stimulation event. Additionally, due to the large amount of ADC data that needs to be translated, processing overhead needs to be small. What does the EEPROM Store? While it may seem logical that the answer to this question is simply the LUTs as described in the section above, this is not the case. Rather, the user can store a calibration point pair , which consists of either a DAC or ADC value and its corresponding physical property, either Voltage or Current . The user can choose to store as little or as many points as they will to a certain limit as defined by the firmware (at the time of writing this is 60 points per data converter). However, storing no or only one calibration point is useless, as storing no points results in every value mapping to zero and storing a single point results in every value mapping to the single point. In both cases the relationship would be flat. Two points and beyond becomes useful. 0 Points Stored 0 Points Stored 1 Points Stored 1 Points Stored 1 Points Stored 1 Points Stored 1 Points Stored 1 Points Stored Viewer does not support full SVG 1.1 It is very likely that the number of calibration points may be lower than the number of entries that the LUT table requires and that the spacing between the pairs are not regular, making them not suitable for placement in the table. Some conversion process has to be performed to achieve this, and this will be discussed further on on this page. However there are benefits to storing arbitrary calibration point pairs: More intuitive from the user perspective (don't need to know what is happening behind) The user does not have to be aware of specific points they need to store They can control either value in the pair and and measure the other (one side of the pair may be easier to control than the other) Note on Similar Points The user is not restricted from storing any calibration pair they desire, this means the user can store pairs where: Both the data converter and electrical properties are identical to another pair The same data converter value paired with different electrical property values The same electrical property values paired with different data converter values The device will handle all three cases without malfunctioning, in the event there are identical calibration pairs , the calibration relationship will look no different as if the identical points were not present. In the other two scenarios things get a bit more complicated since the treatment depends on whether the data converter value or the electrical property value is the independent variable. For DAC calibration points, the electrical property is the independent variable, since current values are mapped to DAC values (ie. every current value can only map to a single DAC value, but the same DAC value can map to multiple current values). For the ADCs the opposite is true, since the ADC value is mapped towards an electrical property. The firmware will only use the first calibration point to appear in EEPROM out of a set of points with equal independent variables . Pair 1 Pair 2 Pair 3 Pair 4 Pair 5 Pair 6 Output Current -3mA -0mA 0mA 0.1mA 3mA 2mA DAC Value 0 2047 2100 2047 4095 3000 The pairs in green are used to perform the LUT table conversion, the pair in red is ignored as the DAC cannot be set to both 2047 and 2100 at the same time. The reason 2100 is ignored is simply because it was the first value in the EEPROM to be stored for 0mA. It is a first come first serve basis. EEPROM to LUT Table Conversion Every time the device starts, the calibration pairs on the EEPROM are processed to produce values for the LUT tables in memory. This also occurs when updating the calibration using the required shell commands. Essentially the points in the LUT table are filled with points interpolated between the calibration pairs stored in the EEPROM. While this may seem like an inefficient way to store the calibration data, since it is quite likely that there will be a lower number of calibration points stored in EEPROM than will be stored in the LUT table, using the LUT table to perform a translation is still faster than interpolating even between only a few calibration pairs in the way that they are stored in EEPROM. Fast Translation Using LUT The whole paradigm revolves around the fact that faster translations can occur between data converter and physical property values when using a regularly spaced LUT rather than an irregularly spaced one. The increased speed comes in finding the interval in which the input point falls not in the actual interpolation. When the intervals are evenly spaced, a simple arithmetic operation can be used to determine the correct interval, when the intervals are irregularly, a search needs to be performed, which depending on implementation can take significantly more time. Additionally the time taken is somewhat dependant on the size of the LUT when irregularly spaced.","title":"Technical Information"},{"location":"technical/#technical-information","text":"This document covers technical information regarding the device, that may be of interest to the advanced user or researcher that needs to understand how the device works at the low levels. The information in here is not required to be read in order to use the device in most circumstances. The quick start guide and user manuals should be the first place to look for help.","title":"Technical Information"},{"location":"technical/#calibration","text":"The Qstim uses both DACs and ADCs to move between the analog and digital domains on the device. The DAC is responsible for converting a current value that is input by the user into a voltage value that is fed to an onboard voltage controlled current source (VCCS) that produces the current output to one of the four outputs on the device. The ADCs are responsible for turning the voltages produced by circuitry that measures channel voltage and current into integer values that can be handled and processed by the processor. In an ideal world where all the electrical components used perfectly match their specified values and the data converter is absolutely linear, the relationship between the data converters digital and analog value is simple and constant across all the devices that have been manufactured. In the real world, this relationship is more complex and varies from device to device. In order to compensate for these differences, the devices have had to incorporate a calibration system that allows each of them to be calibrated according its unique hardware characteristics.","title":"Calibration"},{"location":"technical/#calibration-system-overview","text":"The calibration data is device specific, it depends on the culmination of errors in the electrical components present on the board. For this reason, this data is not built into the firmware, but is stored on an I2C EEPROM present on the device. This makes it easy for the user to re-calibrate the device themselves through the Shell interface Shell Manual. The use of an external EEPROM allows the firmware to stay consistent across all the devices in circulation and makes EEPROM failure a simpler and more cost effective issue to deal with. The EEPROM is completely managed by the processor on board the device, there is no need to use an external programmer to load calibration data, it is both written and read through the devices processor.","title":"Calibration System Overview"},{"location":"technical/#calibration-paradigm","text":"Calibration revolves around mapping a data converter value to a physical property that is being measured or produced either directly or indirectly by the data converter. If the relationship between the two is linear, then all that is required is a some offset and scale value (y = mx+b) to map between the two. If the relationship isn't linear then it can get more complicated. While a mathematical expression relating the two nicely might exist. The development/evaluation of that expression in a reasonable time, might not be possible on a microprocessor with limited performance. A popular calibration paradigm on microprocessors involves lookup tables (LUTs). A LUT stores the physical property value that should be measured/ produced by the data converter for every single input/output level of the data converter. The performance overhead is tiny for the processor to translate between the two values, but comes at the cost of memory consumption. A 12-bit data converter (the resolution of all the data converters used in the device), requires a LUT with 4096 entries to map each level. Due to the large number of data converters used in this device, LUTs could not be implemented. The paradigm chosen was a combination of both the LUT and linear offset and scale. A low density lookup table that maps regularly spaced points in the data converter/physical property relationship is used and linear interpolation is used between the points. Naturally the higher the point density, the more accurate the conversion. This density is controlled by the firmware and has been set to ensure that enough memory is present for other processes. A graphical representation of this paradigm can be seen below. DAC Value DAC Va... Output Property Output... 0 0 4095 4095 Real Relationship Real R... Interpolation between LUT points Interp... Regular Intervals Regula... Viewer does not support full SVG 1.1 The red line represents the relationship between the data converter values and physical properties. The points of contact between the red and blue line represent the points stored in the LUT. Values between these LUT points are linearly interpolated from them. Naturally the least amount of error is present where the blue and red lines are coincident. However as the data converters and the circuits that follow in this device are mostly linear, very little error is present in values between two interpolation points. It is intentional that the points in the LUT have a regular interval on the axis that is being translated from. The reason for this is that there is less of a processing overhead in finding which interval a given value falls in than if the intervals were irregularly sized. This is important as the current to DAC value needs to be done fast to allow for current updates during a stimulation event. Additionally, due to the large amount of ADC data that needs to be translated, processing overhead needs to be small.","title":"Calibration Paradigm"},{"location":"technical/#what-does-the-eeprom-store","text":"While it may seem logical that the answer to this question is simply the LUTs as described in the section above, this is not the case. Rather, the user can store a calibration point pair , which consists of either a DAC or ADC value and its corresponding physical property, either Voltage or Current . The user can choose to store as little or as many points as they will to a certain limit as defined by the firmware (at the time of writing this is 60 points per data converter). However, storing no or only one calibration point is useless, as storing no points results in every value mapping to zero and storing a single point results in every value mapping to the single point. In both cases the relationship would be flat. Two points and beyond becomes useful. 0 Points Stored 0 Points Stored 1 Points Stored 1 Points Stored 1 Points Stored 1 Points Stored 1 Points Stored 1 Points Stored Viewer does not support full SVG 1.1 It is very likely that the number of calibration points may be lower than the number of entries that the LUT table requires and that the spacing between the pairs are not regular, making them not suitable for placement in the table. Some conversion process has to be performed to achieve this, and this will be discussed further on on this page. However there are benefits to storing arbitrary calibration point pairs: More intuitive from the user perspective (don't need to know what is happening behind) The user does not have to be aware of specific points they need to store They can control either value in the pair and and measure the other (one side of the pair may be easier to control than the other)","title":"What does the EEPROM Store?"},{"location":"technical/#note-on-similar-points","text":"The user is not restricted from storing any calibration pair they desire, this means the user can store pairs where: Both the data converter and electrical properties are identical to another pair The same data converter value paired with different electrical property values The same electrical property values paired with different data converter values The device will handle all three cases without malfunctioning, in the event there are identical calibration pairs , the calibration relationship will look no different as if the identical points were not present. In the other two scenarios things get a bit more complicated since the treatment depends on whether the data converter value or the electrical property value is the independent variable. For DAC calibration points, the electrical property is the independent variable, since current values are mapped to DAC values (ie. every current value can only map to a single DAC value, but the same DAC value can map to multiple current values). For the ADCs the opposite is true, since the ADC value is mapped towards an electrical property. The firmware will only use the first calibration point to appear in EEPROM out of a set of points with equal independent variables . Pair 1 Pair 2 Pair 3 Pair 4 Pair 5 Pair 6 Output Current -3mA -0mA 0mA 0.1mA 3mA 2mA DAC Value 0 2047 2100 2047 4095 3000 The pairs in green are used to perform the LUT table conversion, the pair in red is ignored as the DAC cannot be set to both 2047 and 2100 at the same time. The reason 2100 is ignored is simply because it was the first value in the EEPROM to be stored for 0mA. It is a first come first serve basis.","title":"Note on Similar Points"},{"location":"technical/#eeprom-to-lut-table-conversion","text":"Every time the device starts, the calibration pairs on the EEPROM are processed to produce values for the LUT tables in memory. This also occurs when updating the calibration using the required shell commands. Essentially the points in the LUT table are filled with points interpolated between the calibration pairs stored in the EEPROM. While this may seem like an inefficient way to store the calibration data, since it is quite likely that there will be a lower number of calibration points stored in EEPROM than will be stored in the LUT table, using the LUT table to perform a translation is still faster than interpolating even between only a few calibration pairs in the way that they are stored in EEPROM.","title":"EEPROM to LUT Table Conversion"},{"location":"technical/#fast-translation-using-lut","text":"The whole paradigm revolves around the fact that faster translations can occur between data converter and physical property values when using a regularly spaced LUT rather than an irregularly spaced one. The increased speed comes in finding the interval in which the input point falls not in the actual interpolation. When the intervals are evenly spaced, a simple arithmetic operation can be used to determine the correct interval, when the intervals are irregularly, a search needs to be performed, which depending on implementation can take significantly more time. Additionally the time taken is somewhat dependant on the size of the LUT when irregularly spaced.","title":"Fast Translation Using LUT"},{"location":"usbinterface/","text":"USB Interface The device can be connected to a standard USB 2.0 port on the computer using the provided USB 2.0 to USB C cable. Alternatively a USB C to USB C cable can be used to connect the device to a computer with a USB C port. The device functionality does not change in either case. The device is compatible with Windows, macOS and Linux. The device should be plug and play with all of them. If issues occur drivers can be obtained from FTDI Chip if using a Rev3D stimulator. Rev3E stimulators and onwards do not use external drivers. The device is controlled using a standard serial interface and provides a shell interface that can controlled via a terminal. There exist a number of terminal emulators both open source and commercial that can be used with the device. Some options are given below: Windows : Tera Term (free), PuTTY (free) macOS : screen (built-in), Serial (paid) Linux : screen (free) Serial Port Settings These settings must used regardless of which operating system or terminal emulator has been chosen. These settings are set in the terminal emulator software itself. The name of the serial port provided by the device is dependant on the operating system. View the quick start guide for a walk through on connecting the device to a PC. Parameter Setting Baud Rate 115200 Data Bits 8 Parity none Stop Bits 1 If the terminal program has an option to add a transmit line delay, a value of around 20 milliseconds should be given to allow time for the stimulator to respond to commands when copy pasting a large block of commands at once.","title":"USB Interface"},{"location":"usbinterface/#usb-interface","text":"The device can be connected to a standard USB 2.0 port on the computer using the provided USB 2.0 to USB C cable. Alternatively a USB C to USB C cable can be used to connect the device to a computer with a USB C port. The device functionality does not change in either case. The device is compatible with Windows, macOS and Linux. The device should be plug and play with all of them. If issues occur drivers can be obtained from FTDI Chip if using a Rev3D stimulator. Rev3E stimulators and onwards do not use external drivers. The device is controlled using a standard serial interface and provides a shell interface that can controlled via a terminal. There exist a number of terminal emulators both open source and commercial that can be used with the device. Some options are given below: Windows : Tera Term (free), PuTTY (free) macOS : screen (built-in), Serial (paid) Linux : screen (free)","title":"USB Interface"},{"location":"usbinterface/#serial-port-settings","text":"These settings must used regardless of which operating system or terminal emulator has been chosen. These settings are set in the terminal emulator software itself. The name of the serial port provided by the device is dependant on the operating system. View the quick start guide for a walk through on connecting the device to a PC. Parameter Setting Baud Rate 115200 Data Bits 8 Parity none Stop Bits 1 If the terminal program has an option to add a transmit line delay, a value of around 20 milliseconds should be given to allow time for the stimulator to respond to commands when copy pasting a large block of commands at once.","title":"Serial Port Settings"}]}